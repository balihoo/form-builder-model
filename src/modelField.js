// Generated by CoffeeScript 2.4.1
(function() {
  var ModelBase, ModelField, ModelOption, Mustache, globals, jiff;

  ModelBase = require('./modelBase');

  ModelOption = require('./modelOption');

  globals = require('./globals');

  Mustache = require('mustache');

  jiff = require('jiff');

  module.exports = ModelField = (function() {
    class ModelField extends ModelBase {
      initialize() {
        var ref, ref1;
        this.setDefault('type', 'text');
        this.setDefault('options', []);
        this.setDefault('value', (function() {
          switch (this.get('type')) {
            case 'multiselect':
              return [];
            case 'bool':
              return false;
            case 'info':
            case 'button':
              return void 0;
            default:
              return (this.get('defaultValue')) || '';
          }
        }).call(this));
        this.setDefault('defaultValue', this.get('value'));
        this.set('isValid', true);
        this.setDefault('validators', []);
        this.setDefault('onChangeHandlers', []);
        this.setDefault('dynamicValue', null);
        this.setDefault('template', null);
        this.setDefault('autocomplete', null);
        this.setDefault('beforeInput', function(val) {
          return val;
        });
        this.setDefault('beforeOutput', function(val) {
          return val;
        });
        if ((ref = this.type) !== 'info' && ref !== 'text' && ref !== 'url' && ref !== 'email' && ref !== 'tel' && ref !== 'time' && ref !== 'date' && ref !== 'textarea' && ref !== 'bool' && ref !== 'tree' && ref !== 'color' && ref !== 'select' && ref !== 'multiselect' && ref !== 'image' && ref !== 'button' && ref !== 'number') {
          return globals.handleError(`Bad field type: ${this.type}`);
        }
        this.bindPropFunctions('dynamicValue');
        while ((Array.isArray(this.value)) && (this.type !== 'multiselect') && (this.type !== 'tree') && (this.type !== 'button')) {
          this.value = this.value[0];
        }
        if (typeof this.value === 'string' && (this.type === 'multiselect')) {
          this.value = [this.value];
        }
        if (this.type === 'bool' && typeof this.value !== 'bool') {
          this.value = !!this.value;
        }
        this.makePropArray('validators');
        this.bindPropFunctions('validators');
        this.makePropArray('onChangeHandlers');
        this.bindPropFunctions('onChangeHandlers');
        if (this.optionsFrom != null) {
          this.ensureSelectType();
          if ((this.optionsFrom.url == null) || (this.optionsFrom.parseResults == null)) {
            return globals.handleError('When fetching options remotely, both url and parseResults properties are required');
          }
          if (typeof ((ref1 = this.optionsFrom) != null ? ref1.url : void 0) === 'function') {
            this.optionsFrom.url = this.bindPropFunction('optionsFrom.url', this.optionsFrom.url);
          }
          if (typeof this.optionsFrom.parseResults !== 'function') {
            return globals.handleError('optionsFrom.parseResults must be a function');
          }
          this.optionsFrom.parseResults = this.bindPropFunction('optionsFrom.parseResults', this.optionsFrom.parseResults);
        }
        this.updateOptionsSelected();
        this.on('change:value', function() {
          var changeFunc, i, len, ref2;
          ref2 = this.onChangeHandlers;
          for (i = 0, len = ref2.length; i < len; i++) {
            changeFunc = ref2[i];
            changeFunc();
          }
          return this.updateOptionsSelected();
        });
        return this.on('change:type', function() {
          if (this.type === 'multiselect') {
            this.value = this.value.length > 0 ? [this.value] : [];
          } else if (this.previousAttributes().type === 'multiselect') {
            this.value = this.value.length > 0 ? this.value[0] : '';
          }
          if (this.options.length > 0 && !this.isSelectType()) {
            return this.type = 'select';
          }
        });
      }

      getOptionsFrom() {
        var ref, url;
        if (this.optionsFrom == null) {
          return;
        }
        url = typeof this.optionsFrom.url === 'function' ? this.optionsFrom.url() : this.optionsFrom.url;
        if (this.prevUrl === url) {
          return;
        }
        this.prevUrl = url;
        return typeof window !== "undefined" && window !== null ? (ref = window.formbuilderproxy) != null ? ref.getFromProxy({
          url: url,
          method: this.optionsFrom.method || 'get',
          headerKey: this.optionsFrom.headerKey
        }, (error, data) => {
          var i, len, mappedResults, opt, results;
          if (error) {
            return globals.handleError(globals.makeErrorMessage(this, 'optionsFrom', error));
          }
          mappedResults = this.optionsFrom.parseResults(data);
          if (!Array.isArray(mappedResults)) {
            return globals.handleError('results of parseResults must be an array of option parameters');
          }
          this.options = [];
          results = [];
          for (i = 0, len = mappedResults.length; i < len; i++) {
            opt = mappedResults[i];
            results.push(this.option(opt));
          }
          return results;
        }) : void 0 : void 0;
      }

      field(...obj) {
        return this.parent.field(...obj);
      }

      group(...obj) {
        return this.parent.group(...obj);
      }

      option(...optionParams) {
        var newOption, nextOpts, opt, optionObject;
        optionObject = this.buildParamObject(optionParams, ['title', 'value', 'selected', 'bidAdj', 'bidAdjFlag']);
        this.ensureSelectType();
        nextOpts = (function() {
          var i, len, ref, results;
          ref = this.options;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            opt = ref[i];
            if (opt.title !== optionObject.title) {
              results.push(opt);
            }
          }
          return results;
        }).call(this);
        newOption = new ModelOption(optionObject);
        nextOpts.push(newOption);
        this.options = nextOpts;
        if (newOption.selected) {
          this.addOptionValue(newOption.value);
        }
        return this;
      }

      postBuild() {
        this.defaultValue = this.value;
        return this.updateOptionsSelected();
      }

      updateOptionsSelected() {
        var bidAdj, bidValue, i, len, opt, ref, ref1, results;
        ref = this.options;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          opt = ref[i];
          if ((ref1 = this.type) === 'multiselect' || ref1 === 'tree') {
            bidValue = this.hasValue(opt.value);
            bidAdj = bidValue.bidAdjValue.lastIndexOf('/') !== -1 ? bidValue.bidAdjValue.split('/').pop(): "+0%";
            opt.selected = bidValue.selectStatus;
            results.push(opt.bidAdj = bidAdj !== -1 ? bidAdj : "0%");
          } else {
            results.push(opt.selected = this.hasValue(opt.value));
          }
        }
        return results;
      }

      isSelectType() {
        var ref;
        return (ref = this.type) === 'select' || ref === 'multiselect' || ref === 'image' || ref === 'tree';
      }

      ensureSelectType() {
        if (!this.isSelectType()) {
          return this.type = 'select';
        }
      }

      child(value) {
        var i, len, o, ref;
        if (Array.isArray(value)) {
          value = value.shift();
        }
        ref = this.options;
        for (i = 0, len = ref.length; i < len; i++) {
          o = ref[i];
          if (o.value === value) {
            return o;
          }
        }
      }

      validator(func) {
        this.validators.push(this.bindPropFunction('validator', func));
        this.trigger('change');
        return this;
      }

      onChange(f) {
        this.onChangeHandlers.push(this.bindPropFunction('onChange', f));
        this.trigger('change');
        return this;
      }

      setDirty(id, whatChanged) {
        var i, len, opt, ref;
        ref = this.options;
        for (i = 0, len = ref.length; i < len; i++) {
          opt = ref[i];
          opt.setDirty(id, whatChanged);
        }
        return super.setDirty(id, whatChanged);
      }

      setClean(all) {
        var i, len, opt, ref, results;
        if (all) {
          ref = this.options;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            opt = ref[i];
            results.push(opt.setClean(all));
          }
          return results;
        }
      }

      recalculateRelativeProperties() {
        var dirty, i, j, len, len1, opt, ref, ref1, results, validator, validityMessage, value;
        dirty = this.dirty;
        if (this.shouldCallTriggerFunctionFor(dirty, 'isValid')) {
          validityMessage = void 0;
          if (this.template) {
            validityMessage || (validityMessage = this.validate.template.call(this));
          }
          if (this.type === 'number') {
            validityMessage || (validityMessage = this.validate.number.call(this));
          }
          if (!validityMessage) {
            ref = this.validators;
            for (i = 0, len = ref.length; i < len; i++) {
              validator = ref[i];
              if (typeof validator === 'function') {
                validityMessage = validator.call(this);
              }
              if (typeof validityMessage === 'function') {
                return globals.handleError(`A validator on field '${this.name}' returned a function`);
              }
              if (validityMessage) {
                break;
              }
            }
          }
          this.validityMessage = validityMessage;
          this.set({
            isValid: validityMessage == null
          });
        }
        if (this.template && this.shouldCallTriggerFunctionFor(dirty, 'value')) {
          this.renderTemplate();
        } else {
          if (typeof this.dynamicValue === 'function' && this.shouldCallTriggerFunctionFor(dirty, 'value')) {
            value = this.dynamicValue();
            if (typeof value === 'function') {
              return globals.handleError(`dynamicValue on field '${this.name}' returned a function`);
            }
            this.set('value', value);
          }
        }
        if (this.shouldCallTriggerFunctionFor(dirty, 'options')) {
          this.getOptionsFrom();
        }
        ref1 = this.options;
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          opt = ref1[j];
          results.push(opt.recalculateRelativeProperties());
        }
        return results;
      }

      addOptionValue(val, bidAdj) {
        var findMatch, ref;
        if ((ref = this.type) === 'multiselect' || ref === 'tree') {
          if (!Array.isArray(this.value)) {
            this.value = [this.value];
          }
          findMatch = this.value.findIndex(function(e) {
            return val.search(e) !== -1;
          });
          if (findMatch !== -1 && (bidAdj != null)) {
            return this.value[findMatch] = val + "/" + bidAdj;
          } else {
            if (bidAdj != null) {
              return this.value.push(val + "/" + bidAdj);
            } else {
              return this.value.push(val);
            }
          }
        } else {
          return this.value = val;
        }
      }

      removeOptionValue(val) {
        var ref;
        if ((ref = this.type) === 'multiselect' || ref === 'tree') {
          return this.value = this.value.filter(function(v) {
            return v.search(val) === -1;
          });
        } else if (this.value === val) {
          return this.value = '';
        }
      }

      hasValue(val) {
        var findMatch, ref;
        if ((ref = this.type) === 'multiselect' || ref === 'tree') {
          findMatch = this.value.findIndex(function(e) {
            return e.search(val) !== -1;
          });
          if (findMatch !== -1) {
            return {
              "bidAdjValue": this.value[findMatch],
              "selectStatus": true
            };
          } else {
            return {
              "selectStatus": false
            };
          }
        } else {
          return val === this.value;
        }
      }

      buildOutputData(_, skipBeforeOutput) {
        var out, value;
        value = (function() {
          switch (this.type) {
            case 'number':
              out = +this.value;
              if (isNaN(out)) {
                return null;
              } else {
                return out;
              }
              break;
            case 'info':
            case 'button':
              return void 0;
            case 'bool':
              return !!this.value;
            default:
              return this.value;
          }
        }).call(this);
        if (skipBeforeOutput) {
          return value;
        } else {
          return this.beforeOutput(value);
        }
      }

      clear(purgeDefaults = false) {
        if (purgeDefaults) {
          return this.value = (function() {
            switch (this.type) {
              case 'multiselect':
                return [];
              case 'bool':
                return false;
              default:
                return '';
            }
          }).call(this);
        } else {
          return this.value = this.defaultValue;
        }
      }

      ensureValueInOptions() {
        var existingOption, i, j, k, len, len1, len2, o, ref, ref1, ref2, results, v;
        if (!this.isSelectType()) {
          return;
        }
        if (typeof this.value === 'string') {
          ref = this.options;
          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            if (o.value === this.value) {
              existingOption = o;
            }
          }
          if (!existingOption) {
            return this.option(this.value, {
              selected: true
            });
          }
        } else if (Array.isArray(this.value)) {
          ref1 = this.value;
          results = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            v = ref1[j];
            existingOption = null;
            ref2 = this.options;
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              o = ref2[k];
              if (o.value === v) {
                existingOption = o;
              }
            }
            if (!existingOption) {
              results.push(this.option(v, {
                selected: true
              }));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      }

      applyData(inData, clear = false, purgeDefaults = false) {
        if (clear) {
          this.clear(purgeDefaults);
        }
        if (inData != null) {
          this.value = this.beforeInput(jiff.clone(inData));
          return this.ensureValueInOptions();
        }
      }

      renderTemplate() {
        var template;
        if (typeof this.template === 'object') {
          template = this.template.value;
        } else {
          template = this.parent.child(this.template).value;
        }
        try {
          return this.value = Mustache.render(template, this.root.data);
        } catch (error1) {

        }
      }

    };

    ModelField.prototype.modelClassName = 'ModelField';

    ModelField.prototype.validityMessage = void 0;

    return ModelField;

  }).call(this);

}).call(this);
